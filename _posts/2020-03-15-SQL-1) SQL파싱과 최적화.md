
```
---
SQL

SQL은 기본적으로 구조적이고 집합적이고 선언적인 질의 언어이다
(structured, set-based, declarative)

원하는 결과집합을 구조적, 집합적으로 선언하지만,
그 결과집합을 만드는 과정은 절차적일 수밖에 없다

즉 프로시저가 필요한데, 그런 프로시저를 만들어내는 DBMS
내부 엔진이 바로 SQL 옵티마이저이다. 

옵티마이저가 프로그래밍을 대신해주는 셈이다.

---
DBMS 내부에서 프로시저를 작성하고 
컴파일해서 실행 가능한 상태로 만드는 전 과정을
SQL 최적화라고 한다 

---
최적화 관련 
-논리적 I/O는 통제 가능하나 
 물리적 I/O는 통제가 거의 불가하다 
 
 *논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 
  곧 SQL 튜닝 
  
  BCHR (버퍼 캐시 히트율)
  -BCHR이 SQL 성능을 좌우하지만 
   BCHR이 높다고 해서 효율적인 SQL을 의미하지는 않는다 
   일례로 같은 블록을 비효율적으로 반복해서 읽으면 
   BCHR이 높아진다.
   
---
카디널리티
-중복도가 '낮으면' 카디널리티가 '높다'고 표현한다
 중복도가 '높으면' 카디널리티가 '낮다'고 표현한다

출처
https://itholic.github.io/database-cardinality/

---
메모리 공유 자원에 대한 액세스 직렬화 

버퍼 캐시는 SGA 구성요소이므로 버퍼캐시에 캐싱된 버퍼
블록은 모두 공유자원이다
공유자원은 말 그대로 모두에게 권한이 있기 때문에
누구나 접근 가능 

* 문제는 하나의 버퍼블록을 두 개 이상 프로세스가
'동시에' 접근하려고 할 때 발생한다.
동시에 접근하면 블록 정합성에 문제가 발생할 수 있기
때문이다

* 따라서 자원을 공유하는 것처럼 보여도 내부에선
한 프로세스씩 순차적으로 접근하도록 구현해야 하며
이를 위해 직렬화(쉬운뜻으로 줄세우기) 메커니즘이 
필요하다 

* 캐시버퍼 체인 래치
대량의 데이터를 읽을 때 모든 블록에 대해 해시 체인을
탐색한다
DBA(Data Block Address)를 해시 함수에 입력하고
거기서 반환된 값으로 스캔해야 할 해시 체인을
찾는다. 해시 체인을 스캔하는 동안
다른 프로세스가 체인 구조를 변경하는 일이 생기면
곤란하다. 이를 막기 위해 해시 체인 래치가 존재한다

SGA를 구성하는 서브 캐시마다 별도의 래치가 
존재하는데 버퍼캐시에는 캐시버퍼 체인래치,
캐시버퍼 LRU 체인 래치등이 작동한다

빠른 데이터베이스를 구현하려면 버퍼캐시 히트율을
높여야 하지만, 캐시 I/O도 생각만큼
빠르지 않을 수 있다

이들 래치에 의한 경합이 생길 수 있기 때문이다

캐시버퍼 체인뿐만 아니라 버퍼블록 자체에도 직렬화
메커니즘이 존재한다.
-> * 버퍼락
(캐시버퍼 체인 래치를 해제하기 전에
버퍼 헤더에 Lock를 설정함으로써
버퍼블록 자체에 대한 직렬화 문제를 해결하는 것이다)

* 같은 로우는 로우 Lock에 의해 보호될 텐데
버퍼 Lock가 왜 필요할까 싶겠지만,
로우 Lock을 설정하는 행위도 블록을 변경하는
작업이다. 로우 Lock을 설정하는 순간 
다른 프로세스가 해당 블록을 읽는다면
문제가 생긴다. 그뿐만 아니라 같은 블록에서
서로 다른 로우를 동시에 읽고 쓰는 경우를
막기 위해서도 버퍼 Lock는 필요하다 


이런 직렬화 메커니즘에 의한 캐시 경합을
줄이려면, SQL 튜닝을 통해
논리적 I/O 자체를 줄여야 한다



---
```

























     
     
     
     
     
     
     
     
     
     
     
     
     






